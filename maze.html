<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Python処理＋JS描画による迷路最短経路探索</title>
  <style>
    body { font-family: monospace; }
    .maze { margin: 10px 0; }
    .cell { width: 24px; height: 24px; display: inline-block; text-align: center; vertical-align: middle; }
    .wall { background: #222; }
    .empty { background: #fff; }
    .path { background: #4dd; }
    .start { background: #4f4; }
    .goal { background: #f44; }
    .border { background: #888; }
  </style>
</head>
<body>
  <h2>Python処理＋JS描画による迷路最短経路探索</h2>
  <button onclick="runMazeSolve()">最短経路を探索する</button>
  <div id="maze" class="maze"></div>
  <div id="result"></div>

<script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
<script>
const JS_MAZE = [
    [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0],
    [1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0],
    [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
    [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0],
    [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0],
    [0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0],
    [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1],
    [0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0],
    [1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0],
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0],
    [1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0],
    [0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]
];

let pyodideReady = false;
let pyodide = null;

async function loadPyodideAndPackages() {
  pyodide = await loadPyodide();
  pyodideReady = true;
}
loadPyodideAndPackages();

function drawMaze(maze) {
    const mazeDiv = document.getElementById('maze');
    mazeDiv.innerHTML = '';
    for (let y = 0; y < maze.length; y++) {
        for (let x = 0; x < maze[0].length; x++) {
            let className = 'cell';
            if (maze[y][x] == 1) className += ' wall';
            else if (maze[y][x] == 0) className += ' empty';
            else if (maze[y][x] == 2) className += ' path';
            else if (maze[y][x] == 3) className += ' start';
            else if (maze[y][x] == 4) className += ' goal';
            mazeDiv.innerHTML += `<span class="${className}">&nbsp;</span>`;
        }
        mazeDiv.innerHTML += "<br>";
    }
}

async function runMazeSolve() {
  if (!pyodideReady) return;
  document.getElementById('maze').innerHTML = '計算中...';
  document.getElementById('result').textContent = '';

  // JSの迷路配列→Pythonリスト表現
  let pyMazeCode = "maze = [\n";
  for (let row of JS_MAZE) {
    pyMazeCode += "    [" + row.join(",") + "],\n";
  }
  pyMazeCode += "]\n";

  // Pythonスクリプト本体（あなたのロジックそのまま＆迷路mazeは外から注入）
  let pyCode = pyMazeCode + `
# 迷路解決処理 (あなたのPythonコードそのまま)
from copy import deepcopy as dc
start = (0, 0)
end = (29, 29)
trueend = ((end[0]+1, end[1]+1))
truestart = ((start[0]+1, start[1]+1))

stack = [(start[0] + 1, start[1] + 1)]
next_stack = []

new_maze = []
new_maze.append(["."]*(len(maze[0])+2))
for i in range(len(maze)):
    new_l = ["."]
    for j in range(len(maze[0])):
        if maze[i][j] == 0:
            new_l.append(0)
        else:
            new_l.append(".")
    new_l.append(".")
    new_maze.append(new_l)
new_maze.append(["."]*(len(maze[0])+2))
new_maze[stack[0][1]][stack[0][0]] = 's'
keep_maze = dc(new_maze)

distance = 1
while trueend not in stack:
    check = False
    for x, y in stack:
        for i in range(4):
            if i == 0: # 上
                if new_maze[y - 1][x] == 0:
                    new_maze[y - 1][x] = distance
                    next_stack.append((x, y - 1))
                    check = True
            if i == 1: # 右
                if new_maze[y][x + 1] == 0:
                    new_maze[y][x + 1] = distance
                    next_stack.append((x + 1, y))
                    check = True
            if i == 2: # 下
                if new_maze[y + 1][x] == 0:
                    new_maze[y + 1][x] = distance
                    next_stack.append((x, y + 1))
                    check = True
            if i == 3: # 左
                if new_maze[y][x - 1] == 0:
                    new_maze[y][x - 1] = distance
                    next_stack.append((x - 1, y))
                    check = True
    if not check:
        print("エラー：スタートとゴールがつながっていない可能性があります。")
        break
    stack = next_stack
    next_stack = []
    distance += 1

x, y = trueend
distance = new_maze[y][x]

while distance > 1:
    moved = False
    for i in range(4):
        if i == 0 and y > 0:  # 上
            if new_maze[y - 1][x] == distance - 1:
                y -= 1
                distance -= 1
                keep_maze[y][x] = 2
                break
        if i == 1 and x < len(new_maze[0]) - 1:  # 右
            if new_maze[y][x + 1] == distance - 1:
                x += 1
                distance -= 1
                keep_maze[y][x] = 2
                break
        if i == 2 and y < len(new_maze) - 1:  # 下
            if new_maze[y + 1][x] == distance - 1:
                y += 1
                distance -= 1
                keep_maze[y][x] = 2
                break
        if i == 3 and x > 0:  # 左
            if new_maze[y][x - 1] == distance - 1:
                x -= 1
                distance -= 1
                keep_maze[y][x] = 2
                break

for i in keep_maze:
    for j in range(len(i)):
        if i[j] == ".":
            i[j] = 1
        elif i[j] == "s":
            i[j] = 3

keep_maze[trueend[1]][trueend[0]] = 4

# JS側で使いやすい形でprint（2次元配列：0,1,2,3,4）
for row in keep_maze:
    print("ROW:" + ",".join(str(cell) for cell in row))
`;

  let result = '';
  pyodide.setStdout({ batched: s => result += s + '\n' });
  pyodide.setStderr({ batched: s => result += s + '\n' });
  await pyodide.runPythonAsync(pyCode);

  // 最短経路付き迷路の配列を抽出
  let maze = [];
  let errMsg = '';
  for (let line of result.split('\n')) {
    if (line.startsWith('ROW:')) {
      let arr = line.replace('ROW:', '').split(',').map(Number);
      maze.push(arr);
    } else if (line.startsWith('エラー')) {
      errMsg += line + '\n';
    }
  }
  if (maze.length > 0) {
    drawMaze(maze);
    document.getElementById('result').textContent = (errMsg ? errMsg : '') + "凡例: ■=壁 □=空白 ■=道 ●=スタート ◆=ゴール";
  } else {
    document.getElementById('maze').textContent = "エラー: 計算できませんでした";
    document.getElementById('result').textContent = errMsg || result;
  }
}

// 初期表示
drawMaze(JS_MAZE);
</script>
</body>
</html>
